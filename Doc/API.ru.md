
# Протокол взаимодействия
Протокол взаимодействия реализован на базе библиотеки [Protobuf](https://developers.google.com/protocol-buffers) от Google. Весь интерфейс описан в виде одного файла [Protocol.proto](https://github.com/ziminas1990/space-expansion/blob/master/Protocol.proto). Файл написан с использованием спецификации языка ["Proto3 language guide"](https://developers.google.com/protocol-buffers/docs/proto3).  
Для обмена сообщениями между сервером и клиентом используется протокол UDP, без каких-либо дополнительных заголовков для обнаружения/восстановления потерь. Возможно в будущем такой заголовок появится.  
Задачи реализации обмена по UDP и [интеграции библиотеки protobuf](https://developers.google.com/protocol-buffers/docs/tutorials) в Ваш проект не будут рассматриваться в данной статье. Далее будем считать, что Вы уже умеете отправлять и принимать protobuf-сообщения и сосредоточимся на рассмотрении логики обмена сообщениями.

# Сообщение верхнего уровня
Клиент и сервер могут обмениваться между собой исключительно сообщениями **Message**:
```protobuf
message Message {
  uint32 tunnelId = 1;

  oneof choice {
    // All possible interfaces are listed here
    Message           encapsulated     = 2;
    IAccessPanel      accessPanel      = 3;
    ICommutator       commutator       = 4;
    IShip             ship             = 5;
    INavigation       navigation       = 6;
    IEngine           engine           = 7;
    ICelestialScanner celestialScanner = 8;
    IAsteroidScanner  asteroid_scanner = 9;
    // и другие интерфейсы....
  }
}
```
Как видно, данное сообщение является контейнером для любого другого сообщения, в т.ч. для вложенного сообщения **Message**. По мере добавления новых модулей, их сообщения так же будут добавляться в **Message**. Каждое из возможных вложенных сообщений будет рассмотрено ниже.

Кроме того, что Message является контейнером для других сообщений, он имеет одно дополнительное поле **tunnelId**. Это номер туннеля или номер виртуального канала. Оно так же будет рассмотрено ниже, при обсуждении интерфейса **ICommutator**.

В дальнейшем, мы будем считать что **любое** сообщение, отправленное на сервер или полученное от сервера, была "упаковано" в сообщение **Message**.  
Например, если нужно отправить на сервер сообщение **LoginRequest**, которое является частью интерфейса **IAccessPanel** (о нём речь пойдёт ниже), то необходимо:
  - создать сообщение Message;
  - в сообщение Message вложить сообщение IAccessPanel;
  - в сообщение IAccessPanel вложить сообщение LoginRequest.
 
 Т.е. сообщение будет иметь вид:
 ![encapsulate-example](https://i.ibb.co/Ss1yQKT/encapsulation-example.png)

# Авторизация и интерфейс IAccessPanel
Для того, чтобы начать работу с сервером, необходимо авторизоваться. Авторизация реализована достаточно просто - для этой задачи предусмотрен интерфейс IAccessPanel:
```protobuf
message IAccessPanel {
  message LoginRequest {
    string login    = 1;
    string password = 2;
    string ip       = 3;
    uint32 port     = 4;
  }
  message LoginSuccess {
    uint32 port     = 1;
  }
  message LoginFailed {
    string reason   = 1;
  }
  
  oneof choice {
    LoginRequest login        = 1;
    
    LoginSuccess loginSuccess = 21;
    LoginFailed  loginFailed  = 22;
  }
}
```

Данный интерфейс имеет единственную команду **LoginRequest**, в которой нужно указать:
  - **login** - имя пользователя;
  - **password** - пароль для доступа;
  - **ip:port** - IP-адрес (IPv4) и порт, с которого сервер должен принимать сообщения; все сообщения полученные с другого адреса будут проигнорированы;

Сообщение **LoginRequest** должно быть отправлено на IP:Port, на котором сервер принимает запросы на авторизацию. Их можно уточнить у администратора сервера.

> Напомню, что прежде чем отправить сообщение LoginRequest, его необходимо обернуть в сообщение IAccessPanel, которое, в свою очередь, нужно обернуть в сообщение Message! Подробнее см. п. "Сообщение верхнего уровня"

В ответ сервер может отправить одно из двух сообщений:
  - **LoginSuccess** - сообщает об успешной авторизации; передаёт порт **port**, на который необходимо отправлять все последующие сообщения;
  - **LoginFailed** - сообщает об ошибке авторизации; в поле **reason** возвращает описание ошибки.

После успешной авторизации сервер открывает UDP-порт на порту **port**, который был передан в ответе **LoginSuccess** и ожидает сообщения от отправителя **IP:Port**, которые были указаны в **LoginRequest**.

# Что такое коммутатор?
**Коммутатор** - это устройство для создания **туннелей** или **виртуальных каналов** связи к устройствам, подключенным к коммутатору.
Коммутатор имеет **слоты** - точки для подключения других устройств. Устройством может выступать модуль, корабль или другой коммутатор. Во внутренней памяти коммутатора есть **таблица коммутации**, которая выглядит, например, так:

| Номер туннеля | Номер слота |
|---------------|-------------|
|  4            |  5          |
|  12           |  5          |
|  21           |  3          |

В данном случае её можно трактовать так:
1. сообщение, поступившее по туннелю #4 необходимо перенаправить устройство, подключённому к слоту #5
2. сообщение, поступившее по туннелю #12 необходимо перенаправить устройство, подключённому к слоту #5
3. сообщение, поступившее по туннелю #21 необходимо перенаправить устройство, подключённому к слоту #3

По сути, **туннель** - это правило в таблице коммутации. Как видно в данном примере, к устройству, подключенному к слоту #5 идёт сразу 2 туннеля: туннель #4 и туннель #12. Такая ситуация вполне допустима. Однако ситуация, когда один туннель подключен к нескольким устройствам **недопустима**.

Интерфейс коммутатора позволяет:
  - изучить список модулей, подключенных к коммутатору;
  - открывать/закрывать туннели (т.е. добавлять/удалять записи в таблицу коммутации);
  - туннелировать сообщения устройствам, подключенным к коммутатору.

## Что такое корневой коммутатор?
Когда игрок подключается к серверу, он получает доступ к **корневому коммутатору**. К этому коммутатору подключены все корабли, которыми игрок может управлять. Каждый корабль имеет в своём составе коммутатор, к которому подключены все модули. Таким образом, в самом простом случае имеем двухуровневую иерархию. Однако в реальности, она может быть глубже, например так:
![commutators example](https://i.ibb.co/2FrstsP/Commutators.png)

## Как коммутатор туннелирует сообщения?
Коммутатор хранит в своей внутренней памяти **таблицу коммутации**, где каждому номеру туннеля сопоставляется номер слота к устройству, к которому открыт данный туннель.

Если на коммутатор поступает сообщение **Message**, в которое упаковано **другое сообщение Message**, то коммутатор выполняет следующие действия:
  1. смотрит на поле **nTunnelId** поступившего сообщения;
  2. находит в таблице коммутации запись, с таким же номером nTunnelId;
  3. из записи получает номер слота **nSlotId** устройства, к которому был открыт данный туннель;
  4. **изымает** из полученного сообщения **Message** вложенное сообщение Message и **передаёт** его устройству, подключенному к слоту **nSlotId** (т.е. выполняет деинкапсуляцию).

Как было показано выше, вполне допустима ситуация, что к одному коммутатору подключен другой коммутатор. Поэтому если сообщению необходимо пройти через цепочку коммутаторов, оно **несколько раз** упаковывается в сообщение **Message**, и на каждом уровне указывается свой номер туннеля. Пример такого туннелирования:
![deencapsulation-example](https://i.ibb.co/XysZvvy/deencapsulation-example.png)


# Интерфейс ICommutator
Интерфейс коммутатора наиболее сложный из всех и описан в виде сообщения **ICommutator**:
```protobuf
message ICommutator {

  message GetTotalSlots {}
  message GetTotalSlotsResponse {
    uint32 nTotalSlots = 1;
  }

  message GetModuleInfo {
    uint32 nSlotId     = 1;
  }
  message GetAllModulesInfo {}
  message ModuleInfo {
    uint32 nSlotId     = 1;
    string sModuleType = 2;
  }

  message OpenTunnel {
    uint32 nSlotId   = 2;
  }
  message OpenTunnelSuccess {
    uint32 nTunnelId = 2;
  }
  message OpenTunnelFailed {}

  message CloseTunnel {
    uint32 nTunnelId = 1;
  }
  message TunnelClosed {
    uint32 nTunnelId = 1;
  }

  oneof choice {
    // Requests and command from Client
    GetTotalSlots     getTotalSlots          = 1;
    GetModuleInfo     getModuleInfo          = 2;
    GetAllModulesInfo getAllModulesInfo      = 3;
    OpenTunnel        openTunnel             = 4;
    CloseTunnel       closeTunnel            = 5;

    // Responces and indications from server
    GetTotalSlotsResponse totalSlotsResponse = 41;
    ModuleInfo            moduleInfo         = 42;
    OpenTunnelSuccess     openTunnelSuccess  = 43;
    OpenTunnelFailed      openTunnelFailed   = 44; 
    TunnelClosed          tunnelClosed       = 45;
  }
}
```

Как видно, у него есть следующие команды:
  - **getTotalSlots** - получить общее количество слотов на коммутаторе;
  - **getModuleInfo** - получить информацию об устройстве, подключенном к некоторому слоту;
  - **getAllModulesInfo** - получить информацию сразу о всех устройствах, подключенных к коммутатору;
  - **openTunnel** - открыть виртуальный канал к некоторому устройству;
  - **closeTunnel** - закрыть некоторый виртуальный канал.

## Как получить список устройств, подключенных к коммутатору?
Прежде всего, необходимо выяснить, сколько всего устройств подключено к коммутатору. Для этого необходимо отправить запрос **getTotalSlots**. В качестве ответа от сервера поступит сообщение **totalSlotsResponse**, единственным параметром которого является общее количество подключенных устройств **nTotalSlots**.

После этого можно запросить список всех устройств, отправив запрос **getAllModulesInfo**. В ответ поступит несколько сообщений **moduleInfo**, в каждом из которых будет указано:
  - **nSlotId** - номер слота, к которому подключено устройство;
  - **sModuleType** - тип устройства.
Всего таких сообщений поступит столько же, сколько устройств подключено к коммутатору.

Другой способ - отправить запрос **getModuleInfo**, указав в качестве единственного параметра номер слота **nSlotId**, который принимает значения от 0 до N-1 включительно, где N - общее количество слотов. В ответ на него так же поступит единственное сообщение **moduleInfo**, где будет указан тот же самый номер слота **nSlotId** и тип устройства **sModuleType**.

Тип устройства - это строка, состоящая из двух слов, разделённых "/":
```
Класс/Модель
```
**Класс** устройства определяет, какие интерфейсы устройство поддерживает, т.е. какие команды оно способно обрабатывать. Например:

| Класс      | Поддерживаемые интерфейсы |
|------------|---------------------------|
| Ship       | ICommutator, INavigation  |
| Engine     | IEngine                   |
| Commutator | ICommutator               |

**"/Модель"** - это опциональная часть типа и она может быть опущена. Она не влияет на список поддерживаемых устройством интерфейсов, однако служит некоторым показателем важных характеристик устройства и его применимости в тех или иных задачах. Например:  
**Engine/Chemical** - химический двигатель; создаёт огромную тягу и потребляет большое количество топлива; может быть использован для экстренных манёвров, быстрого ускорения или торможения;  
**Engine/Nuclear** - ядерный двигатель; является менее мощной альтернативой химическому двигателю, однако требует для своей работы гораздо меньше (по массе) топлива; может быть использован для умеренного маневрирования;  
**Engine/Ion** - ионный двигатель; выдаёт очень маленькую тягу, однако имеет практически неограниченный запас топлива; может быть использован для небольшого но постоянного ускорения/торможения, и незначительных корректировок курса при длительных перелётах.

Модель двигателя может быть и не указана.

## Как передать сообщение на устройство?
Чтобы отправлять сообщение на устройство, подключенное к коммутатору, недостаточно просто знать номер слота, к которому устройство подключено. Необходимо открыть **туннель** или **виртуальный канал** к устройству. Для этого нужно отправить на коммутатор команду **OpenTunnel**:
```protobuf
message OpenTunnel {
  uint32 nSlotId   = 2;
}
```

Единственный параметр команды **nSlotId** - это номер слота, к которому подключено целевое устройство. В ответ на команду сервер отправит сообщение 
```protobuf
message OpenTunnelSuccess {
  uint32 nTunnelId = 2;
}
```
, единственным параметром которого является **nTunnelId** - уникальный (в рамках данного коммутатора) номер туннеля.

Теперь, для того, чтобы передать некоторое сообщение **Message** устройству, необходимо упаковать это сообщение в ещё одно сообщение **Message**, в котором в качестве параметра **nTunnelId** указать номер туннеля, полученный в ответе **OpenTunnelSuccess**.

В случае, если открыть туннель не удалось, коммутатор отправляет ответ **OpenTunnelFailed**:
```protobuf
message  OpenTunnelFailed {}
```

## Как закрыть туннель?
Чтобы закрыть туннель, нужно отправить сообщение **CloseTunnel**:
```protobuf
message CloseTunnel {
  uint32 nTunnelId = 1;
}
```

Если такой туннель существует, то сервер закроет его и на клиент будет отправлено сообщение **TunnelClosed**:
```protobuf
message TunnelClosed {
  uint32 nTunnelId = 1;
}
```

Это же сообщение будет отправлено на клиент если туннель закроется по каким-то иным причинам. Например, если устройство, к которому он подключен, будет выведено из строя, либо уничтожено.

# Интерфейс INavigation
У объекта, реализующего данный интерфейс, можно запросить информацию о его текущем местоположении и скорости.
```protobuf
message INavigation {

  message GetPosition {}
  message GetPositionResponse {
    double x   = 1;
    double y   = 2;
    double vx  = 4;
    double vy  = 5;
  }
  
  oneof choice {
    GetPosition positionRequest = 1;
    
    GetPositionResponse positionResponse = 2;
  }
}
```

Интерфейс имеет единственный запрос **GetPosition**. Если объект реализует данный интерфейс, то в ответ на запрос он отправит сообщение **GetPositionResponse**, в котором будут указаны текущее местоположение объекта (x, y), и его скорость (vx, vy).


# Корабль и интерфейс IShip
Корабль реализует следующие интерфейсы:
  * **ICommutator** - центральный корабельный коммутатор, к которому подключено всё оборудование корабля;
  * **INavigation** - через этот интерфейс можно определить текущее местоположение и скорость корабля;
  * **IShip** - интерфейс для получения информации о состоянии корабля.
 
 Интерфейсы ICommutator и INavigation уже рассматривались выше. Рассмотрим интерфейс IShip:
```protobuf
message IShip {
  message GetState {}
  message GetStateResponse {
    double weight = 1;
  }

  oneof choice {
    GetState         stateRequest = 1;

    GetStateResponse stateResponse = 21;
  }
}
```

Единственный запрос **GetState** позволяет получить информацию о состоянии корабля. В ответе **GetStateResponse** возвращаются следующие данные:

| Параметр | Ед. изм. | Возможные значения | Описание              |
|----------|----------|--------------------|-----------------------|
| weight   | кг       | > 0                | Текущая масса корабля |

# Двигатели
## Что есть двигатель?
Двигатели - это модули класса **"Engine"**. Такие модели позволяют создавать вектор тяги - силу, действующую на объект, на который установлен двигатель.

В текущей версии двигатель сильно упрощён:
  - имеет единственный параметр - **максимальная сила тяги**, выраженная в Ньютонах;
  - может изменять свой вектор тяги **моментально** как по силе, так и по направлению;
  - запас топлива неограничен;
  - топливо имеет нулевую массу, т.е. работе двигателя не влияет на массу корабля.

С развитием игры и повышением уровня сложности, все эти упрощения будут постепенно устраняться.

## Интерфейс IEngine
Основной интерфейс управления двигателем - **IEngine**:
```protobuf
message IEngine
{

  message GetSpecification {}
  message Specification {
    uint32 maxThrust = 1;
  }
  
  message SetThrust {
    double x           = 1;
    double y           = 2;
    uint32 thrust      = 4;
    uint32 duration_ms = 5;
  }
  
  message GetThrust {}
  
  message CurrentThrust {
    double x      = 1;
    double y      = 2;
    uint32 thrust = 4;
  }

  oneof choice {
    GetSpecification getSpecification = 1;
    SetThrust        setThrust        = 2;
    GetThrust        getThrust        = 3;
    
    Specification    specification    = 21;
    CurrentThrust    currentThrust    = 22;
  }
}
```
## Как получить параметры двигателя?
Чтобы получить параметры двигателя, нужно отправить запрос **GetSpecification**. В ответ двигатель отправит сообщение **Specification**, в котором передаются следующие параметры:

| Параметр   | Ед. изм. | Возможные значения | Описание                                     |
|------------|----------|--------------------|----------------------------------------------|
| max_thrust | H        | >= 0               | Максимально допустимое значение вектора тяги |

## Как управлять вектором тяги двигателя?
Для того, чтобы установить вектор тяги двигателя, нужно отправить команду **SetThrust**:
```protobuf
message SetThrust {
  double x           = 1;
  double y           = 2;
  uint32 thrust      = 4;
  uint32 duration_ms = 5;
}
```
, где:
  - **x** и **y** задают **направление** вектора тяги;
  -  **thrust** определяет силу вектора тяги, выраженную в Ньютонах; если указанная сила превышает максимально возможную для данного двигателя, то ~~двигатель взрывается~~ будет выставлена максимально возможная;
  - **duration_ms** - время работы двигателя в миллисекундах; если указать 0, то время работы не ограничено.

Для того, чтобы получить текущее значение вектора тяги, нужно отправить запрос **GetThrust**. В ответ поступит сообщение:
```protobuf
message CurrentThrust {
  double x      = 1;
  double y      = 2;
  uint32 thrust = 4;
}
```
, где:
  - **x, y** - направление векторf тяги;
  - **thrust**- сила вектора тяги (в Ньютонах).

# Сканер небесных объектов
## Логика работы сканера
Модули класса **CelestialScanner** позволяют обнаруживать нерукотворные небесные объекты, такие как астероиды и планеты. Имеет следующие параметры:
  - **максимальный радиус сканирования (в км)**;
  - **удельное время обработки сигнала** - время, требуемой на обработку сигнала при сканировании с **разрешением** = 1.

При сканировании указывается **разрешение сканирования**, или **resolution** - это отношение радиуса сканирования к минимальному радиусу объекта, который можно обнаружить. Например, если требуется обнаружить все объекты радиусом не меньше чем 10 метров в радиусе километра, то потребуется запустить сканирование с разрешением **resolution =** 1000 м / 10 м**= 100**. 

Сканер работает не мгновенно - на обработку запроса ему требуется определённое время. Можно разбить работу сканера на несколько этапов:
1. **калибровка** - выполняется перед каждым сканированием и требует **100ms** игрового времени;
2. **ожидание отражённого сигнала** - сканер отправляет сигнал и ожидает его отражение от объектов;
3. **обработка сигнала** - время, требуемое сканеру на обработку сигнала при 

Считаем, что сигнал перемещается со скоростью света. Соответственно, если требуется сканировать пространство в радиусе 300 000 км, то до получения отражённого сигнала сканеру придётся ожидать 2 секунды.

**Время обработки сигнала** прямо-пропорционально разрешению сканирования, т.е. чем выше разрешение, тем больше времени потребуется на обработку отражённого сигнала.

Таким образом, формула для вычисления времени сканирования имеет вид:
```
t = 0.1 + 2 * R / c + processing_time * resolution.
```
, где:
  - **R** - радиус сканирования;
  - **processing_time** - удельное время обработки результатов сканирования;
  - **resolution** - разрешение сканирования.
## Интерфейс ICelestialScanner
Все модули класса "CelestialScanner" реализуют интерфейс **ICelestialScanner**:
```protobuf
message ICelestialScanner {
  message GetSpecification {}
  message Specification {
    uint32 max_radius_km      = 1;
    uint32 processing_time_us = 2;
  }

  message Scan {
    uint32 scanning_radius_km = 1;
    uint32 minimal_radius_m   = 2;
  }

  message ScanResults {
    message AsteroidInfo {
      uint32 id = 1;
      double x  = 2;
      double y  = 3;
      double vx = 4;
      double vy = 5;
      double r  = 6;
    }
    
    repeated AsteroidInfo asteroids = 1;
    uint32                left      = 2;
  }

  message ScannerBusy {}
  
  oneof choice {
    GetSpecification get_specification = 1;
    Scan             scan              = 2;
    
    Specification specification  = 21;
    ScanResults   scan_result    = 22;
    ScannerBusy   busy_response  = 23;
  }  
}
```
## Как получить параметры сканера?
Чтобы получить параметры сканера, нужно отправить запрос **GetSpecification**. В ответ поступит следующее сообщение **Specification**:
```protobuf
message Specification {
  uint32 max_radius_km      = 1;
  uint32 processing_time_us = 2;
}
```
, где:
  * **max_radius_km** - максимальный радиус сканирования в киллометрах;
  * **processing_time_us** - удельное время анализа отражённого сигнала, в микросекундах.

## Как сканировать?
Для того, чтобы запустить сканирование, необходимо отправить следующую команду:
```protobuf
message Scan {
  uint32 scanning_radius_km = 1;
  uint32 minimal_radius_m   = 2;
}
```
, где:
  * **scanning_radius_km** - радиус сканирования;
  * **minimal_radius_m** - минимальный радиус обнаруживаемых объектов.

Данная команда запустит сканирование с разрешением
```
resolution = (1000 * scanning_radius_km) / minimal_radius_m
```
После успешного сканирования в ответ поступит одно или несколько следующих сообщений:
```protobuf
message ScanResults {
  message AsteroidInfo {
    uint32 id = 1;
    double x  = 2;
    double y  = 3;
    double vx = 4;
    double vy = 5;
    double r  = 6;
  }
  
  repeated AsteroidInfo asteroids = 1;
  uint32                left      = 2;
}
```
, где:
  * **asteroids** - список обнаруженных астероидов;
  * **left** - сколько астероидов ещё не передано.

Если список обнаруженных астероидов большой, то сканер не будет отправлять его целиком. Вместо этого, он отправит **несколько** сообщений ScanResult, в каждом из которых будет передана информация только по небольшому количеству астероидов (например, по 10 астероидов за раз). Если очередное полученное сообщение **завершает** передачу списка астероидов, то в поле **left** будет записано значение 0. В противном случае, в поле left будет записано количество астероидов, которое будет передано в последующих сообщениях.

Каждый астероид описывается следующим набором параметров:
  * **id** - уникальный идентификатор астероида; будем считать, что каждому астероиду ~~повесили табличку~~ выделили некоторый его уникальный номер и он почему-то известен всем сканерам; это условность, которая облегчит в будущем жизнь всем нам;
  * **x, y** - положение астероида;
  * **vx, vy** - вектор скорости астероида;
  * **r** - радиус астероида.

Если отправить на сканер команду **ScanRequest** во время обработки им другой команды **ScanRequest**, то сканер вернёт сообщение **ScannerBusy**. Т.е. сканер не может выполнять два запроса одновременно, при этом приоритет отдаётся первому поступившему запросу.

## Усложнение механики сканирования
Усложнение механики сканеров планируется следующим образом:
  * у сканера будете предельное разрешение сканирования;
  * ответ будет поступать не одновременно для всех объектов, а постепенно, вначале по более близким объектам, затем по более удалённым;
  * чем ближе угловые размеры объекта к максимальной разрешающей способности сканера, тем с большей погрешностью сканер сообщает их радиус, позицию и скорость.

# Изучение состава астероида
В текущей версии игры астероиды являются источниками трёх ресурсов:
1. металлы;
2. лёд;
3. силикаты.

При этом соотношение этих ресурсов у разных астероидов может быть различным. Чтобы исследовать примерный состав астероида, нужно использовать модули класса **"AsteroidScanner"**.

## Интерфейс IAsteroidScanner
Все модули класса "AsteroidScanner" реализуют интерфейс IAsteroidScanner:
```protobuf
message IAsteroidScanner {

  message GetSpecification {}
  message Specification {
    uint32 max_distance    = 1;
    uint32 scanning_time_k = 2;
  }
  
  message ScanRequest {
    uint32 asteroid_id = 1;
  }
  message ScanResult {
    uint32 asteroid_id       = 1;
    double weight            = 2;
    double metals_percent    = 3;
    double ice_percent       = 4;
    double silicates_percent = 5;
  }
  message ScanFailed {}


  oneof choice {
    GetSpecification get_specification = 1;
    ScanRequest      scan_request      = 2;
    
    Specification    specification     = 21;
    ScanResult       scan_result       = 22;
    ScanFailed       scan_failed       = 23;
  }
}
```

## Как получить параметры сканера?
Чтобы получить параметры сканера, нужно отправить запрос **GetSpecification**. В ответ поступит следующее сообщение **Specification**:
```protobuf
message Specification {
  uint32 max_distance    = 1;
  uint32 scanning_time_k = 2;
}
```
, где:
  * **max_distance** - максимальная дистанция до астероида, выражена в метрах;
  * **scanning_time_k ** - время, требуемое на сканирование 1 гектара поверхности (100 x 100 метров).

## Как сканировать астероид?
Для того, чтобы просканировать астероид, необходимо:
1. обнаружить астероид; например, используя модуль, реализующий интерфейс *ICelestialScanner*;
2. подлететь к нему на дистанцию, не превышающую **max_distance**;
3. запустить сканирование, отправив команду **scan_request**;
4. до тех пор, пока не поступит ответ, держаться от астероида на дистанции, не превышающей *max_distance*.

Запрос **scan_request**:
```protobuf
message ScanRequest {
  uint32 asteroid_id = 1;
}
```
, где:
  * **asteroid_id** - уникальный идентификатор астероида; можно получить, например, сканируя астероиды через интерфейс *ICelestialScanner*.

Ответ на запрос имеет вид:
```protobuf
message ScanResult {
  uint32 asteroid_id       = 1;
  double weight            = 2;
  double metals_percent    = 3;
  double ice_percent       = 4;
  double silicates_percent = 5;
}
```
, где:
  * **asteroid_id** - уникальный идентификатор астероида;
  * **weight** - масса астероида, в килограммах;
  * **metals_percent** - процент металлов;
  * **ice_percent** - процент льда;
  * **silicates_percent**- процент силикатов.

В случае, если сканирование астероида не удалось, сканер отправляет сообщение **ScanFailed**. Оно может быть отправлено по следующим причинам:
  * уже запущена другая задача сканирования;
  * расстояние до астероида превышает максимально допустимое *max_distance*;
  * в процессе сканирования корабль отдалился от астероида на дистанцию, превышающую *max_distance*.
