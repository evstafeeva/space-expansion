# Интерфейс ICommutator
Интерфейс коммутатора наиболее сложный из всех и описан в виде сообщения **ICommutator**:
```protobuf
message ICommutator {

  message GetTotalSlots {}
  message GetTotalSlotsResponse {
    uint32 nTotalSlots = 1;
  }

  message GetModuleInfo {
    uint32 nSlotId     = 1;
  }
  message GetAllModulesInfo {}
  message ModuleInfo {
    uint32 nSlotId     = 1;
    string sModuleType = 2;
  }

  message OpenTunnel {
    uint32 nSlotId   = 2;
  }
  message OpenTunnelSuccess {
    uint32 nTunnelId = 2;
  }
  message OpenTunnelFailed {}

  message CloseTunnel {
    uint32 nTunnelId = 1;
  }
  message TunnelClosed {
    uint32 nTunnelId = 1;
  }

  oneof choice {
    // Requests and command from Client
    GetTotalSlots     getTotalSlots          = 1;
    GetModuleInfo     getModuleInfo          = 2;
    GetAllModulesInfo getAllModulesInfo      = 3;
    OpenTunnel        openTunnel             = 4;
    CloseTunnel       closeTunnel            = 5;

    // Responces and indications from server
    GetTotalSlotsResponse totalSlotsResponse = 41;
    ModuleInfo            moduleInfo         = 42;
    OpenTunnelSuccess     openTunnelSuccess  = 43;
    OpenTunnelFailed      openTunnelFailed   = 44; 
    TunnelClosed          tunnelClosed       = 45;
  }
}
```

Как видно, у него есть следующие команды:
  - **getTotalSlots** - получить общее количество слотов на коммутаторе;
  - **getModuleInfo** - получить информацию об устройстве, подключенном к некоторому слоту;
  - **getAllModulesInfo** - получить информацию сразу о всех устройствах, подключенных к коммутатору;
  - **openTunnel** - открыть виртуальный канал к некоторому устройству;
  - **closeTunnel** - закрыть некоторый виртуальный канал.

## Как получить список устройств, подключенных к коммутатору?
Прежде всего, необходимо выяснить, сколько всего устройств подключено к коммутатору. Для этого необходимо отправить запрос **getTotalSlots**. В качестве ответа от сервера поступит сообщение **totalSlotsResponse**, единственным параметром которого является общее количество подключенных устройств **nTotalSlots**.

После этого можно запросить список всех устройств, отправив запрос **getAllModulesInfo**. В ответ поступит несколько сообщений **moduleInfo**, в каждом из которых будет указано:
  - **nSlotId** - номер слота, к которому подключено устройство;
  - **sModuleType** - тип устройства.
Всего таких сообщений поступит столько же, сколько устройств подключено к коммутатору.

Другой способ - отправить запрос **getModuleInfo**, указав в качестве единственного параметра номер слота **nSlotId**, который принимает значения от 0 до N-1 включительно, где N - общее количество слотов. В ответ на него так же поступит единственное сообщение **moduleInfo**, где будет указан тот же самый номер слота **nSlotId** и тип устройства **sModuleType**.

Тип устройства - это строка, состоящая из двух слов, разделённых "/":
```
Класс/Модель
```
**Класс** устройства определяет, какие интерфейсы устройство поддерживает, т.е. какие команды оно способно обрабатывать. Например:

| Класс      | Поддерживаемые интерфейсы |
|------------|---------------------------|
| Ship       | ICommutator, INavigation  |
| Engine     | IEngine                   |
| Commutator | ICommutator               |

**"/Модель"** - это опциональная часть типа и она может быть опущена. Она не влияет на список поддерживаемых устройством интерфейсов, однако служит некоторым показателем важных характеристик устройства и его применимости в тех или иных задачах. Например:  
**Engine/Chemical** - химический двигатель; создаёт огромную тягу и потребляет большое количество топлива; может быть использован для экстренных манёвров, быстрого ускорения или торможения;  
**Engine/Nuclear** - ядерный двигатель; является менее мощной альтернативой химическому двигателю, однако требует для своей работы гораздо меньше (по массе) топлива; может быть использован для умеренного маневрирования;  
**Engine/Ion** - ионный двигатель; выдаёт очень маленькую тягу, однако имеет практически неограниченный запас топлива; может быть использован для небольшого но постоянного ускорения/торможения, и незначительных корректировок курса при длительных перелётах.

Модель двигателя может быть и не указана.

## Как передать сообщение на устройство?
Чтобы отправлять сообщение на устройство, подключенное к коммутатору, недостаточно просто знать номер слота, к которому устройство подключено. Необходимо открыть **туннель** или **виртуальный канал** к устройству. Для этого нужно отправить на коммутатор команду **OpenTunnel**:
```protobuf
message OpenTunnel {
  uint32 nSlotId   = 2;
}
```

Единственный параметр команды **nSlotId** - это номер слота, к которому подключено целевое устройство. В ответ на команду сервер отправит сообщение 
```protobuf
message OpenTunnelSuccess {
  uint32 nTunnelId = 2;
}
```
, единственным параметром которого является **nTunnelId** - уникальный (в рамках данного коммутатора) номер туннеля.

Теперь, для того, чтобы передать некоторое сообщение **Message** устройству, необходимо упаковать это сообщение в ещё одно сообщение **Message**, в котором в качестве параметра **nTunnelId** указать номер туннеля, полученный в ответе **OpenTunnelSuccess**.

В случае, если открыть туннель не удалось, коммутатор отправляет ответ **OpenTunnelFailed**:
```protobuf
message  OpenTunnelFailed {}
```

## Как закрыть туннель?
Чтобы закрыть туннель, нужно отправить сообщение **CloseTunnel**:
```protobuf
message CloseTunnel {
  uint32 nTunnelId = 1;
}
```

Если такой туннель существует, то сервер закроет его и на клиент будет отправлено сообщение **TunnelClosed**:
```protobuf
message TunnelClosed {
  uint32 nTunnelId = 1;
}
```

Это же сообщение будет отправлено на клиент если туннель закроется по каким-то иным причинам. Например, если устройство, к которому он подключен, будет выведено из строя, либо уничтожено.
